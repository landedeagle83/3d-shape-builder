<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Shape Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #e0e0e0;
            font-size: 13px;
        }

        /* Main Layout */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Top Toolbar */
        .top-toolbar {
            height: 48px;
            background: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 8px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
            border-right: 1px solid #3a3a3a;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: #b0b0b0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.15s;
        }

        .toolbar-btn:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .toolbar-btn.active {
            background: #00a884;
            color: #fff;
        }

        .toolbar-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .app-title {
            font-weight: 600;
            font-size: 15px;
            color: #fff;
            margin-right: 20px;
        }

        .spacer {
            flex: 1;
        }

        /* Main Content Area */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left Panel - Object List */
        .left-panel {
            width: 220px;
            background: #252525;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 12px;
            font-weight: 600;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            border-bottom: 1px solid #3a3a3a;
        }

        .object-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .object-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            gap: 8px;
            margin-bottom: 2px;
        }

        .object-item:hover {
            background: #333;
        }

        .object-item.selected {
            background: #00a884;
            color: #fff;
        }

        .object-item.group {
            font-weight: 500;
        }

        .object-icon {
            font-size: 16px;
        }

        .object-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .object-visibility {
            opacity: 0.5;
            cursor: pointer;
        }

        .object-visibility:hover {
            opacity: 1;
        }

        /* Center - Viewport */
        .viewport {
            flex: 1;
            position: relative;
            background: #1e1e1e;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .viewport-info {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(0,0,0,0.7);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            color: #888;
        }

        /* Right Panel - Properties */
        .right-panel {
            width: 260px;
            background: #252525;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }

        .properties-section {
            padding: 12px;
            border-bottom: 1px solid #3a3a3a;
        }

        .section-title {
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #888;
            margin-bottom: 10px;
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .property-label {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 11px;
            margin-right: 8px;
        }

        .property-label.x { background: #e74c3c; color: #fff; }
        .property-label.y { background: #2ecc71; color: #fff; }
        .property-label.z { background: #3498db; color: #fff; }

        .property-input {
            flex: 1;
            height: 28px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #e0e0e0;
            padding: 0 8px;
            font-size: 12px;
            font-family: inherit;
        }

        .property-input:focus {
            outline: none;
            border-color: #00a884;
        }

        /* Color Picker */
        .color-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .color-swatch {
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border-color: #fff;
        }

        /* Bottom Panel - Shape Library */
        .bottom-panel {
            height: 140px;
            background: #252525;
            border-top: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }

        .shape-tabs {
            display: flex;
            border-bottom: 1px solid #3a3a3a;
        }

        .shape-tab {
            padding: 10px 16px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            font-family: inherit;
        }

        .shape-tab:hover {
            color: #fff;
        }

        .shape-tab.active {
            color: #00a884;
            border-bottom-color: #00a884;
        }

        .shape-library {
            flex: 1;
            overflow-x: auto;
            padding: 12px;
            display: flex;
            gap: 8px;
        }

        .shape-card {
            min-width: 80px;
            height: 80px;
            background: #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
            border: 2px solid transparent;
        }

        .shape-card:hover {
            background: #3a3a3a;
            border-color: #00a884;
        }

        .shape-card-icon {
            font-size: 28px;
            margin-bottom: 4px;
        }

        .shape-card-label {
            font-size: 10px;
            color: #888;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
        }

        .modal h3 {
            margin-bottom: 16px;
            font-size: 18px;
        }

        .modal p {
            color: #888;
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .modal-btn {
            width: 100%;
            padding: 12px;
            background: #00a884;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 8px;
            font-family: inherit;
        }

        .modal-btn:hover {
            background: #00c49a;
        }

        .modal-btn.secondary {
            background: #3a3a3a;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 12px 24px;
            border-radius: 8px;
            display: none;
            z-index: 500;
        }

        .toast.show {
            display: block;
            animation: fadeInUp 0.3s;
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translate(-50%, 10px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            /* Hide desktop panels */
            .left-panel { display: none; }
            .right-panel { display: none; }
            
            /* Compact top toolbar */
            .top-toolbar {
                height: 44px;
                padding: 0 8px;
                gap: 4px;
            }
            
            .app-title { 
                font-size: 13px;
                margin-right: 8px;
            }
            
            .toolbar-group {
                padding: 0 4px;
            }
            
            .toolbar-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            /* Larger bottom panel for easier touch */
            .bottom-panel {
                height: 140px;
            }
            
            .shape-library {
                padding: 8px;
                gap: 6px;
            }
            
            .shape-card {
                min-width: 70px;
                height: 70px;
            }
            
            .shape-card-icon {
                font-size: 24px;
            }
            
            /* Viewport takes remaining space */
            .main-content {
                flex: 1;
                overflow: hidden;
            }
            
            .viewport {
                flex: 1;
                min-height: 0;
            }
            
            /* Make help modal smaller */
            .modal {
                max-width: 90%;
                padding: 20px;
            }
            
            .modal h3 {
                font-size: 16px;
            }
            
            .modal p {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Top Toolbar -->
        <div class="top-toolbar">
            <span class="app-title">üé® 3D Shape Studio</span>
            
            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="setMode('select')" id="btn-select" title="Select (V)">üëÜ</button>
                <button class="toolbar-btn" onclick="setMode('move')" id="btn-move" title="Move (G)">‚ú•</button>
                <button class="toolbar-btn" onclick="setMode('rotate')" id="btn-rotate" title="Rotate (R)">üîÑ</button>
                <button class="toolbar-btn" onclick="setMode('scale')" id="btn-scale" title="Scale (S)">‚§¢</button>
            </div>

            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="duplicateSelected()" title="Duplicate (Ctrl+D)">üìã</button>
                <button class="toolbar-btn" onclick="deleteSelected()" title="Delete (Del)">üóëÔ∏è</button>
                <button class="toolbar-btn" onclick="groupSelected()" title="Group (Ctrl+G)">üì¶</button>
                <button class="toolbar-btn" onclick="ungroupSelected()" title="Ungroup (Ctrl+Shift+G)">üì≠</button>
            </div>

            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="mirrorSelected('x')" title="Mirror X">‚ÜîÔ∏è</button>
                <button class="toolbar-btn" onclick="alignObjects('center')" title="Align Center">‚ä°</button>
            </div>

            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="undo()" title="Undo (Ctrl+Z)">‚Ü©Ô∏è</button>
                <button class="toolbar-btn" onclick="redo()" title="Redo (Ctrl+Y)">‚Ü™Ô∏è</button>
            </div>

            <span class="spacer"></span>

            <div class="toolbar-group">
                <button class="toolbar-btn" onclick="exportSTL()" title="Export STL">üíæ</button>
                <button class="toolbar-btn" onclick="export3MF()" title="Export 3MF (Bambu)">üñ®Ô∏è</button>
                <button class="toolbar-btn" onclick="showHelp()" title="Help">‚ùì</button>
            </div>
        </div>

        <div class="main-content">
            <!-- Left Panel - Object List -->
            <div class="left-panel">
                <div class="panel-header">Objects</div>
                <div class="object-list" id="objectList">
                    <div style="padding: 20px; text-align: center; color: #666;">
                        Add shapes to get started
                    </div>
                </div>
            </div>

            <!-- Center - Viewport -->
            <div class="viewport">
                <div id="canvas-container"></div>
                <div class="viewport-info" id="viewportInfo">
                    Objects: 0 | Selected: None
                </div>
            </div>

            <!-- Right Panel - Properties -->
            <div class="right-panel">
                <div class="properties-section">
                    <div class="section-title">Transform</div>
                    <div id="transformProps">
                        <p style="color: #666; font-size: 12px;">Select an object to edit</p>
                    </div>
                </div>

                <div class="properties-section">
                    <div class="section-title">Position</div>
                    <div class="property-row">
                        <span class="property-label x">X</span>
                        <input type="number" class="property-input" id="posX" step="0.1" onchange="updatePosition('x')">
                    </div>
                    <div class="property-row">
                        <span class="property-label y">Y</span>
                        <input type="number" class="property-input" id="posY" step="0.1" onchange="updatePosition('y')">
                    </div>
                    <div class="property-row">
                        <span class="property-label z">Z</span>
                        <input type="number" class="property-input" id="posZ" step="0.1" onchange="updatePosition('z')">
                    </div>
                </div>

                <div class="properties-section">
                    <div class="section-title">Size</div>
                    <div class="property-row">
                        <span class="property-label x">W</span>
                        <input type="number" class="property-input" id="scaleX" step="0.1" min="0.1" onchange="updateScale('x')">
                    </div>
                    <div class="property-row">
                        <span class="property-label y">H</span>
                        <input type="number" class="property-input" id="scaleY" step="0.1" min="0.1" onchange="updateScale('y')">
                    </div>
                    <div class="property-row">
                        <span class="property-label z">D</span>
                        <input type="number" class="property-input" id="scaleZ" step="0.1" min="0.1" onchange="updateScale('z')">
                    </div>
                </div>

                <div class="properties-section">
                    <div class="section-title">Color</div>
                    <div class="color-grid" id="colorGrid"></div>
                </div>
            </div>
        </div>

        <!-- Bottom Panel - Shape Library -->
        <div class="bottom-panel">
            <div class="shape-tabs">
                <button class="shape-tab active" onclick="showShapeCategory('basic')">Basic</button>
                <button class="shape-tab" onclick="showShapeCategory('round')">Round</button>
                <button class="shape-tab" onclick="showShapeCategory('special')">Special</button>
                <button class="shape-tab" onclick="showShapeCategory('building')">Building</button>
            </div>
            <div class="shape-library" id="shapeLibrary"></div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal">
            <h3>üé® 3D Shape Studio</h3>
            <p>Design 3D models for printing!</p>
            <p><strong>Controls:</strong></p>
            <p>üñ±Ô∏è Left click: Select<br>
               üñ±Ô∏è Right drag: Rotate view<br>
               üñ±Ô∏è Scroll: Zoom<br>
               üì± Pinch: Zoom & rotate selected</p>
            <p><strong>Keyboard:</strong></p>
            <p>G: Move | R: Rotate | S: Scale<br>
               Delete: Remove | Ctrl+D: Duplicate<br>
               Ctrl+G: Group | Ctrl+Z: Undo</p>
            <button class="modal-btn" onclick="closeHelp()">Got it! üöÄ</button>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // Core variables
        let scene, camera, renderer, controls, transformControls;
        let objects = [];
        let groups = [];
        let selectedObject = null;
        let currentMode = 'select';
        let objectCounter = 0;
        let undoStack = [];
        let redoStack = [];

        const colors = [
            '#00a884', '#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#1abc9c',
            '#e67e22', '#2ecc71', '#e91e63', '#00bcd4', '#ff5722', '#607d8b'
        ];

        const shapes = {
            basic: [
                { type: 'cube', icon: 'üì¶', label: 'Cube' },
                { type: 'box', icon: 'üìè', label: 'Box' },
                { type: 'plane', icon: '‚¨ú', label: 'Plane' },
                { type: 'pyramid', icon: 'üî∫', label: 'Pyramid' },
                { type: 'wedge', icon: 'üìê', label: 'Wedge' },
                { type: 'prism', icon: 'üìä', label: 'Prism' }
            ],
            round: [
                { type: 'sphere', icon: 'üîÆ', label: 'Sphere' },
                { type: 'hemisphere', icon: 'üåì', label: 'Dome' },
                { type: 'cylinder', icon: 'ü•´', label: 'Cylinder' },
                { type: 'cone', icon: 'üç¶', label: 'Cone' },
                { type: 'capsule', icon: 'üíä', label: 'Capsule' },
                { type: 'disc', icon: 'üîò', label: 'Disc' }
            ],
            special: [
                { type: 'torus', icon: 'üç©', label: 'Donut' },
                { type: 'ring', icon: '‚≠ï', label: 'Ring' },
                { type: 'tube', icon: 'üß™', label: 'Tube' },
                { type: 'star', icon: '‚≠ê', label: 'Star' },
                { type: 'heart', icon: '‚ù§Ô∏è', label: 'Heart' },
                { type: 'gear', icon: '‚öôÔ∏è', label: 'Gear' }
            ],
            building: [
                { type: 'arch', icon: 'üåâ', label: 'Arch' },
                { type: 'corner', icon: 'üìê', label: 'Corner' },
                { type: 'cross', icon: '‚ûï', label: 'Cross' },
                { type: 'hexagon', icon: '‚¨°', label: 'Hexagon' },
                { type: 'octagon', icon: 'üõë', label: 'Octagon' },
                { type: 'ramp', icon: 'üìà', label: 'Ramp' }
            ]
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e);

            // Camera
            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            camera.position.set(15, 15, 15);

            // Renderer
            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Orbit Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // Transform Controls
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', e => {
                controls.enabled = !e.value;
            });
            transformControls.addEventListener('objectChange', () => {
                if (selectedObject) updatePropertiesPanel();
            });
            scene.add(transformControls);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Build Plate (Bambu style)
            createBuildPlate();

            // Event listeners
            renderer.domElement.addEventListener('click', onCanvasClick);
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKeyDown);

            // Initialize UI
            initColorGrid();
            showShapeCategory('basic');
            setMode('select');
            onResize();

            // Show help on first visit
            if (!localStorage.getItem('shapeStudioV2')) {
                showHelp();
            }

            animate();
        }

        function createBuildPlate() {
            // Grid
            const grid = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
            scene.add(grid);

            // Build plate surface
            const plateGeo = new THREE.PlaneGeometry(20, 20);
            const plateMat = new THREE.MeshStandardMaterial({
                color: 0x2a2a2a,
                transparent: true,
                opacity: 0.8
            });
            const plate = new THREE.Mesh(plateGeo, plateMat);
            plate.rotation.x = -Math.PI / 2;
            plate.position.y = -0.01;
            plate.receiveShadow = true;
            plate.userData.isBuildPlate = true;
            scene.add(plate);

            // Plate border
            const borderGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(20, 0.1, 20));
            const borderMat = new THREE.LineBasicMaterial({ color: 0x00a884 });
            const border = new THREE.LineSegments(borderGeo, borderMat);
            border.position.y = 0.05;
            scene.add(border);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // Geometry creation
        function createGeometry(type) {
            const s = 2;
            switch(type) {
                case 'cube': return new THREE.BoxGeometry(s, s, s);
                case 'box': return new THREE.BoxGeometry(s*1.5, s*0.5, s);
                case 'plane': return new THREE.BoxGeometry(s*2, s*0.1, s*2);
                case 'pyramid': return new THREE.ConeGeometry(s/2, s, 4);
                case 'wedge': return createWedge(s);
                case 'prism': return new THREE.CylinderGeometry(s/2, s/2, s, 3);
                case 'sphere': return new THREE.SphereGeometry(s/2, 32, 32);
                case 'hemisphere': return new THREE.SphereGeometry(s/2, 32, 16, 0, Math.PI*2, 0, Math.PI/2);
                case 'cylinder': return new THREE.CylinderGeometry(s/2, s/2, s, 32);
                case 'cone': return new THREE.ConeGeometry(s/2, s, 32);
                case 'capsule': return new THREE.CapsuleGeometry(s/3, s/2, 8, 16);
                case 'disc': return new THREE.CylinderGeometry(s/2, s/2, s*0.15, 32);
                case 'torus': return new THREE.TorusGeometry(s/2, s/6, 16, 32);
                case 'ring': return new THREE.TorusGeometry(s/2, s/10, 8, 32);
                case 'tube': return new THREE.TubeGeometry(
                    new THREE.CatmullRomCurve3([new THREE.Vector3(0,-s/2,0), new THREE.Vector3(0,s/2,0)]),
                    8, s/4, 16, false);
                case 'star': return createStar(s/2, s/4, 5, s/3);
                case 'heart': return createHeart(s);
                case 'gear': return createGear(s/2, s/3, 8, s/3);
                case 'arch': return createArch(s);
                case 'corner': return createCorner(s);
                case 'cross': return createCross(s);
                case 'hexagon': return new THREE.CylinderGeometry(s/2, s/2, s, 6);
                case 'octagon': return new THREE.CylinderGeometry(s/2, s/2, s, 8);
                case 'ramp': return createRamp(s);
                default: return new THREE.BoxGeometry(s, s, s);
            }
        }

        function createWedge(s) {
            const shape = new THREE.Shape();
            shape.moveTo(0, 0); shape.lineTo(s, 0); shape.lineTo(s, s); shape.lineTo(0, 0);
            const geo = new THREE.ExtrudeGeometry(shape, { depth: s, bevelEnabled: false });
            geo.center();
            return geo;
        }

        function createStar(outerR, innerR, points, depth) {
            const shape = new THREE.Shape();
            for (let i = 0; i < points * 2; i++) {
                const r = i % 2 === 0 ? outerR : innerR;
                const a = (i / points) * Math.PI;
                i === 0 ? shape.moveTo(Math.cos(a)*r, Math.sin(a)*r) : shape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
            shape.closePath();
            const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled: false });
            geo.center();
            return geo;
        }

        function createHeart(s) {
            const shape = new THREE.Shape();
            shape.moveTo(0, s/4);
            shape.bezierCurveTo(0, s/2, -s/2, s/2, -s/2, s/4);
            shape.bezierCurveTo(-s/2, 0, 0, -s/4, 0, -s/2);
            shape.bezierCurveTo(0, -s/4, s/2, 0, s/2, s/4);
            shape.bezierCurveTo(s/2, s/2, 0, s/2, 0, s/4);
            const geo = new THREE.ExtrudeGeometry(shape, { depth: s/3, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1 });
            geo.center();
            return geo;
        }

        function createGear(outerR, innerR, teeth, depth) {
            const shape = new THREE.Shape();
            const step = (Math.PI * 2) / (teeth * 2);
            for (let i = 0; i < teeth * 2; i++) {
                const r = i % 2 === 0 ? outerR : innerR;
                const a = i * step - Math.PI / 2;
                i === 0 ? shape.moveTo(Math.cos(a)*r, Math.sin(a)*r) : shape.lineTo(Math.cos(a)*r, Math.sin(a)*r);
            }
            shape.closePath();
            const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled: false });
            geo.center();
            return geo;
        }

        function createArch(s) {
            const shape = new THREE.Shape();
            shape.moveTo(-s/2, 0); shape.lineTo(-s/2, s/2);
            shape.absarc(0, s/2, s/2, Math.PI, 0, false);
            shape.lineTo(s/2, 0); shape.lineTo(s/3, 0); shape.lineTo(s/3, s/2);
            shape.absarc(0, s/2, s/3, 0, Math.PI, true);
            shape.lineTo(-s/3, 0); shape.closePath();
            const geo = new THREE.ExtrudeGeometry(shape, { depth: s/2, bevelEnabled: false });
            geo.center();
            return geo;
        }

        function createCorner(s) {
            const shape = new THREE.Shape();
            shape.moveTo(0, 0); shape.lineTo(s, 0); shape.lineTo(s, s/3);
            shape.lineTo(s/3, s/3); shape.lineTo(s/3, s); shape.lineTo(0, s); shape.closePath();
            const geo = new THREE.ExtrudeGeometry(shape, { depth: s, bevelEnabled: false });
            geo.center();
            return geo;
        }

        function createCross(s) {
            const shape = new THREE.Shape();
            const t = s / 3;
            shape.moveTo(-t, -s); shape.lineTo(t, -s); shape.lineTo(t, -t);
            shape.lineTo(s, -t); shape.lineTo(s, t); shape.lineTo(t, t);
            shape.lineTo(t, s); shape.lineTo(-t, s); shape.lineTo(-t, t);
            shape.lineTo(-s, t); shape.lineTo(-s, -t); shape.lineTo(-t, -t); shape.closePath();
            const geo = new THREE.ExtrudeGeometry(shape, { depth: t, bevelEnabled: false });
            geo.center();
            return geo;
        }

        function createRamp(s) {
            const shape = new THREE.Shape();
            shape.moveTo(0, 0); shape.lineTo(s, 0); shape.lineTo(0, s); shape.closePath();
            const geo = new THREE.ExtrudeGeometry(shape, { depth: s, bevelEnabled: false });
            geo.center();
            return geo;
        }

        // Add shape
        function addShape(type) {
            saveState();
            const geometry = createGeometry(type);
            const color = colors[objectCounter % colors.length];
            const material = new THREE.MeshStandardMaterial({ color, metalness: 0.1, roughness: 0.5 });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.y = 1;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            objectCounter++;
            mesh.userData = {
                id: objectCounter,
                type: type,
                color: color,
                name: type.charAt(0).toUpperCase() + type.slice(1) + ' ' + objectCounter,
                isShape: true
            };

            scene.add(mesh);
            objects.push(mesh);
            selectObject(mesh);
            updateObjectList();
            updateViewportInfo();
            showToast(`Added ${type}`);
        }

        // Selection
        function onCanvasClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((e.clientX - rect.left) / rect.width) * 2 - 1,
                -((e.clientY - rect.top) / rect.height) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(objects, true);
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                while (obj.parent && !obj.userData.isShape && !obj.userData.isGroup) {
                    obj = obj.parent;
                }
                if (obj.userData.isShape || obj.userData.isGroup) {
                    selectObject(obj);
                }
            } else {
                deselectObject();
            }
        }

        function selectObject(obj) {
            if (selectedObject) {
                selectedObject.material.emissive?.setHex(0x000000);
            }
            selectedObject = obj;
            if (obj.material.emissive) {
                obj.material.emissive.setHex(0x222222);
            }
            transformControls.attach(obj);
            updatePropertiesPanel();
            updateObjectList();
            updateViewportInfo();
        }

        function deselectObject() {
            if (selectedObject?.material.emissive) {
                selectedObject.material.emissive.setHex(0x000000);
            }
            selectedObject = null;
            transformControls.detach();
            updatePropertiesPanel();
            updateObjectList();
            updateViewportInfo();
        }

        // Transform modes
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.toolbar-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + mode)?.classList.add('active');
            
            if (mode === 'select') {
                transformControls.detach();
            } else if (selectedObject) {
                transformControls.attach(selectedObject);
                transformControls.setMode(mode === 'move' ? 'translate' : mode);
            }
        }

        // Object operations
        function duplicateSelected() {
            if (!selectedObject) return;
            saveState();
            const clone = selectedObject.clone();
            clone.position.x += 2;
            objectCounter++;
            clone.userData = { ...selectedObject.userData, id: objectCounter, name: selectedObject.userData.type + ' ' + objectCounter };
            scene.add(clone);
            objects.push(clone);
            selectObject(clone);
            updateObjectList();
            showToast('Duplicated');
        }

        function deleteSelected() {
            if (!selectedObject) return;
            saveState();
            scene.remove(selectedObject);
            objects = objects.filter(o => o !== selectedObject);
            transformControls.detach();
            selectedObject = null;
            updateObjectList();
            updateViewportInfo();
            showToast('Deleted');
        }

        function groupSelected() {
            // For now, simple implementation - would need multi-select for full grouping
            showToast('Select multiple objects with Shift+Click to group');
        }

        function ungroupSelected() {
            if (!selectedObject?.userData.isGroup) return;
            showToast('Ungrouped');
        }

        function mirrorSelected(axis) {
            if (!selectedObject) return;
            saveState();
            selectedObject.scale[axis] *= -1;
            updatePropertiesPanel();
            showToast('Mirrored');
        }

        function alignObjects(type) {
            if (!selectedObject) return;
            saveState();
            if (type === 'center') {
                selectedObject.position.x = 0;
                selectedObject.position.z = 0;
            }
            updatePropertiesPanel();
            showToast('Aligned to center');
        }

        // Undo/Redo
        function saveState() {
            const state = objects.map(o => ({
                userData: { ...o.userData },
                position: o.position.clone(),
                rotation: o.rotation.clone(),
                scale: o.scale.clone()
            }));
            undoStack.push(JSON.stringify(state));
            if (undoStack.length > 50) undoStack.shift();
            redoStack = [];
        }

        function undo() {
            if (undoStack.length === 0) return;
            showToast('Undo');
            // Simplified - full implementation would restore state
        }

        function redo() {
            if (redoStack.length === 0) return;
            showToast('Redo');
        }

        // Properties panel
        function updatePropertiesPanel() {
            if (!selectedObject) {
                document.getElementById('posX').value = '';
                document.getElementById('posY').value = '';
                document.getElementById('posZ').value = '';
                document.getElementById('scaleX').value = '';
                document.getElementById('scaleY').value = '';
                document.getElementById('scaleZ').value = '';
                return;
            }
            document.getElementById('posX').value = selectedObject.position.x.toFixed(2);
            document.getElementById('posY').value = selectedObject.position.y.toFixed(2);
            document.getElementById('posZ').value = selectedObject.position.z.toFixed(2);
            document.getElementById('scaleX').value = selectedObject.scale.x.toFixed(2);
            document.getElementById('scaleY').value = selectedObject.scale.y.toFixed(2);
            document.getElementById('scaleZ').value = selectedObject.scale.z.toFixed(2);
            
            // Update color selection
            document.querySelectorAll('.color-swatch').forEach(s => {
                s.classList.toggle('selected', s.dataset.color === selectedObject.userData.color);
            });
        }

        function updatePosition(axis) {
            if (!selectedObject) return;
            saveState();
            const val = parseFloat(document.getElementById('pos' + axis.toUpperCase()).value) || 0;
            selectedObject.position[axis] = val;
        }

        function updateScale(axis) {
            if (!selectedObject) return;
            saveState();
            const map = { x: 'scaleX', y: 'scaleY', z: 'scaleZ' };
            const val = parseFloat(document.getElementById(map[axis]).value) || 1;
            selectedObject.scale[axis] = Math.max(0.1, val);
        }

        function setColor(color) {
            if (!selectedObject) return;
            saveState();
            selectedObject.material.color.setStyle(color);
            selectedObject.userData.color = color;
            updatePropertiesPanel();
        }

        // UI Updates
        function updateObjectList() {
            const list = document.getElementById('objectList');
            if (objects.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">Add shapes to get started</div>';
                return;
            }
            list.innerHTML = objects.map(obj => `
                <div class="object-item ${selectedObject === obj ? 'selected' : ''}" onclick="selectObjectById(${obj.userData.id})">
                    <span class="object-icon">${getShapeIcon(obj.userData.type)}</span>
                    <span class="object-name">${obj.userData.name}</span>
                    <span class="object-visibility">üëÅÔ∏è</span>
                </div>
            `).join('');
        }

        function selectObjectById(id) {
            const obj = objects.find(o => o.userData.id === id);
            if (obj) selectObject(obj);
        }

        function getShapeIcon(type) {
            for (const cat of Object.values(shapes)) {
                const found = cat.find(s => s.type === type);
                if (found) return found.icon;
            }
            return 'üì¶';
        }

        function updateViewportInfo() {
            const info = document.getElementById('viewportInfo');
            info.textContent = `Objects: ${objects.length} | Selected: ${selectedObject?.userData.name || 'None'}`;
        }

        function initColorGrid() {
            const grid = document.getElementById('colorGrid');
            grid.innerHTML = colors.map(c => `
                <div class="color-swatch" style="background:${c}" data-color="${c}" onclick="setColor('${c}')"></div>
            `).join('');
        }

        function showShapeCategory(category) {
            document.querySelectorAll('.shape-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            const library = document.getElementById('shapeLibrary');
            library.innerHTML = shapes[category].map(s => `
                <div class="shape-card" onclick="addShape('${s.type}')">
                    <span class="shape-card-icon">${s.icon}</span>
                    <span class="shape-card-label">${s.label}</span>
                </div>
            `).join('');
        }

        // Export functions
        function exportSTL() {
            if (objects.length === 0) {
                showToast('Add shapes first!');
                return;
            }
            const exporter = new THREE.STLExporter();
            const group = new THREE.Group();
            objects.forEach(o => group.add(o.clone()));
            const stl = exporter.parse(group, { binary: false });
            downloadFile(stl, 'model.stl', 'text/plain');
            showToast('STL exported!');
        }

        function export3MF() {
            if (objects.length === 0) {
                showToast('Add shapes first!');
                return;
            }
            // 3MF is a zip-based format. For now, export STL with instructions
            exportSTL();
            showToast('Open STL in Bambu Studio to print!');
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        // Touch handling
        let touchState = { active: false, startDist: 0, startAngle: 0, startScale: null, startRotation: null };

        function getTouchDistance(t1, t2) {
            return Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
        }

        function getTouchAngle(t1, t2) {
            return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        }

        function onTouchStart(e) {
            if (e.touches.length === 2 && selectedObject) {
                e.preventDefault();
                controls.enabled = false;
                touchState.active = true;
                touchState.startDist = getTouchDistance(e.touches[0], e.touches[1]);
                touchState.startAngle = getTouchAngle(e.touches[0], e.touches[1]);
                touchState.startScale = selectedObject.scale.clone();
                touchState.startRotation = selectedObject.rotation.y;
            }
        }

        function onTouchMove(e) {
            if (e.touches.length === 2 && touchState.active && selectedObject) {
                e.preventDefault();
                const dist = getTouchDistance(e.touches[0], e.touches[1]);
                const angle = getTouchAngle(e.touches[0], e.touches[1]);
                const scaleFactor = dist / touchState.startDist;
                const newScale = Math.max(0.2, Math.min(5, touchState.startScale.x * scaleFactor));
                selectedObject.scale.set(newScale, newScale, newScale);
                selectedObject.rotation.y = touchState.startRotation + (angle - touchState.startAngle);
                updatePropertiesPanel();
            }
        }

        function onTouchEnd() {
            touchState.active = false;
            controls.enabled = true;
        }

        // Keyboard shortcuts
        function onKeyDown(e) {
            if (e.target.tagName === 'INPUT') return;
            
            switch(e.key.toLowerCase()) {
                case 'v': setMode('select'); break;
                case 'g': setMode('move'); break;
                case 'r': setMode('rotate'); break;
                case 's': setMode('scale'); break;
                case 'delete': case 'backspace': deleteSelected(); break;
                case 'd': if (e.ctrlKey || e.metaKey) { e.preventDefault(); duplicateSelected(); } break;
                case 'z': if (e.ctrlKey || e.metaKey) { e.preventDefault(); undo(); } break;
                case 'y': if (e.ctrlKey || e.metaKey) { e.preventDefault(); redo(); } break;
            }
        }

        // Modals & Toast
        function showHelp() {
            document.getElementById('helpModal').classList.add('show');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('show');
            localStorage.setItem('shapeStudioV2', 'true');
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // Initialize
        init();
    </script>
</body>
</html>
